<!DOCTYPE html>
<html>
  <head>
    <title>Hello World</title>
    <link rel="shortcut icon" href="#" />
    <!--
    <script src="https://cdn.8thwall.com/web/aframe/8frame-1.2.0.min.js"></script>
    <script src="https://cdn.8thwall.com/web/xrextras/xrextras.js"></script>
    <script src="https://apps.8thwall.com/xrweb?appKey=f0LPUhzxQRN1kc4sv4mM4ZRsl663KCFL7y7fj3Uc5wN7TNKY7TbKuJlwz5uu0zGbngfYA3"></script>
    <script src="https://unpkg.com/@tensorflow/tfjs-core@3.13.0/dist/tf-core.js"></script>
    <script src="https://unpkg.com/@tensorflow/tfjs-converter@3.13.0/dist/tf-converter.js"></script>
    <script src="https://unpkg.com/@tensorflow/tfjs-backend-webgl@3.13.0/dist/tf-backend-webgl.js"></script>
    <script src="https://unpkg.com/@tensorflow-models/handpose@0.0.7/dist/handpose.js"></script>
    -->

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://supereggbert.github.io/aframe-htmlembed-component/dist/build.js"></script>
    <script src="https://unpkg.com/aframe-text-plane"></script>
    <script src="/socket.io/socket.io.js"></script>

    <style>
      body {
        background-color: black;
      }
      #result-div {
        width: 500px;
        background: #222;
      }
      .word {
        color: white;
      }
      .NN, .NNS, .NNP {
        background-color: gray;
      }
      .highlight-1 {
        background-color: orange;
      }
    </style>

    <script>
      /*
      AFRAME.registerComponent('test', {
        init: function() {
          console.log('test')
          XR8.addCameraPipelineModule(
            XR8.CameraPixelArray.pipelineModule(),
          )
          XR8.addCameraPipelineModule(
            customPipelineModule()
          )
        },
      })

      async function loadModel() {
        window.model = await handpose.load()
      }
      loadModel()

      async function predict(processGpuResult) {
        let width = processGpuResult.camerapixelarray.cols
        let height = processGpuResult.camerapixelarray.rows
        let pixels = processGpuResult.camerapixelarray.pixels
        let imageData = new ImageData(width, height)
        imageData.data.set(pixels)
        let predictions = await window.model.estimateHands(imageData)
        if (predictions && predictions.length > 0) {
          console.log(predictions)
        } else {
          console.log('not found')
        }
      }

      const customPipelineModule = () => {
        return {
          name: 'qrprocess',
          onProcessCpu: ({processGpuResult}) => {
            if (!processGpuResult.camerapixelarray || !processGpuResult.camerapixelarray.pixels) {
              return {found: false}
            }

            try {
              window.processGpuResult = processGpuResult
              predict(processGpuResult)
              return {}
            } catch (e) {
              return {found: false}
            }
          },
        }
      }
      */

      window.SpeechRecognition =
        window.SpeechRecognition || webkitSpeechRecognition;
      recognition = new window.SpeechRecognition();
      recognition.lang = "en-US";
      // recognition.lang = "zh-CN";
      recognition.interimResults = true;
      recognition.continuous = true;
      let textEl = document.querySelector("#text");
      let debugEl = document.querySelector("#debug");

      recognition.addEventListener('error', function(event) {
        debugEl.innerText = event.error + ' and ' + recognition
      })

      let finalTranscript = "";
      recognition.onresult = (event) => {
        let interimTranscript = "";
        for (let i = event.resultIndex; i < event.results.length; i++) {
          let transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            finalTranscript += transcript;
            interimTranscript = "";
          } else {
            interimTranscript += transcript;
          }
          let text = finalTranscript + interimTranscript;
          // debugEl.innerText = value
          // textEl.setAttribute("value", value);
          text = text.replace(/(\r\n|\n|\r)/gm, ' ')
          console.log(`emitting ${text}`)
          socket.emit('message', text)

        }
      };

      recognition.start();

      const socket = io();
      socket.on('message', (data) => {
        let json = JSON.parse(data)
        console.log(json)
        showText(json)
        return

        let resultDiv = document.querySelector("#result-div");
        resultDiv.innerHTML = "";
        let html = getHTML(json);
        resultDiv.innerHTML = html;
        // let res = JSON.stringify(json, null, 2)
        // $("pre").text(res);
      })

      function showText(json) {
        let tokens = json.tokens
        let entities = json.entities
        let html = ""

        let keywords = {}
        for (let entity of entities) {
          keywords[entity.text] = entity.label
        }

        let sceneEl = document.querySelector('a-scene')
        let prev = document.querySelector('a-entity#words')
        if (prev) sceneEl.removeChild(prev)
        let words = document.createElement('a-entity')
        words.setAttribute('id', 'words')
        sceneEl.appendChild(words)

        let pos = { x: -3, y: 0, z: -3}
        let len = 0
        let width = 0
        for (let i = 0; i < tokens.length; i++) {
          let token = tokens[i];
          let word = token.text
          let tag = token.tag

          pos.x += width
          width = word.length/4
          pos.x += width
          let el = document.createElement('a-entity')
          el.setAttribute('id', `word-${i}`)
          el.setAttribute('class', 'word')
          // el.setAttribute('geometry', `primitive: plane; width: ${width}; height: 0.1`)
          // el.setAttribute('material', 'opacity: 0.2; transparent: true')
          // el.setAttribute('text', `height: 0.1; width: ${width}; anchor: center; align: center; wrap-count: ${word.length+1}; color: white; value: ${word}`)
          el.setAttribute('text-plane', `text: ${word}`)
          el.setAttribute('position', `${pos.x} ${pos.y} ${pos.z}`)
          words.appendChild(el)

          console.log(el.object3D)
          // el.object3D.onBeforeRender(sceneEl.renderer, sceneEl.object3D, cameraEl.object3D)
          // setTimeout(() => {
          //   console.log(el.object3D.children)
          //   if (el.object3D.children.length > 0) {
          //     let width = el.object3D.children[0].scale.x
          //     let height = el.object3D.children[0].scale.y
          //     console.log(width)
          //     pos.x += width
          //   }
          // }, 10)

          // console.log(el.object3D.children)
          // if (el.object3D.children.length > 0) {
          //   let width = el.object3D.children[0].scale.x
          //   let height = el.object3D.children[0].scale.y
          //   pos.x += width
          // }
        }
      }

      function getHTML(json) {
        let tokens = json.tokens
        let entities = json.entities
        let html = ""

        let keywords = {}
        for (let entity of entities) {
          keywords[entity.text] = entity.label
        }
        for (let j = 0; j < tokens.length; j++) {
          let token = tokens[j];
          let word = token.text
          let tag = token.tag

          let className = 'word draggable'
          if (Object.keys(keywords).includes(word)) {
            className += ' '
            className += 'highlight-1'
          }
          className += ' '
          className += tag
          html +=
            `<i class="${className}" \
                id="word-${j}-${word}"\
                draggable="true" \
                ondragstart="onDragStart(event)" \
                >` +
            word +
            "</i>" +
            " ";
        }
        return html;
      }

    </script>

  </head>

  <body>

    <a-scene
      test
    >
      <a-camera position="0 0 0" rotation="-45 0 0">
        <a-cursor gaze-event material="color: white;"></a-cursor>
      </a-camera>
      <a-entity htmlembed htmlinit position="0 1 -3">
        <div id="result-div">
          <i class="word">Hello</i><i class="word">World</i>
        </div>
      </a-entity>
    </a-scene>


  </body>
</html>
